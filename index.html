<body>
  <div id="searchActivator"></div>
  <div id="topSearchBar">
    <input type="text" id="searchInput" placeholder="ID –¢–∞–±–ª–æ –∏–ª–∏ –ù–∞–∑–≤–∞–Ω–∏–µ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏"/>
    <button id="searchBtn">üîç</button>
  </div>

  <div id="map"></div>

  <div class="control-buttons">
    <button class="btn" id="legendToggle">–õ–µ–≥–µ–Ω–¥–∞</button>
    <button class="btn" id="worksFilterToggle">
      –†–∞–±–æ—Ç–∞–µ—Ç <span id="worksFilterLabel">–í—Å–µ (0)</span>
    </button>
    <button class="btn" id="statusFilterToggle">
      –°—Ç–∞—Ç—É—Å <span id="statusFilterLabel">–í—Å–µ (0)</span>
    </button>
  </div>

  <div class="overlay" id="overlay"></div>
  <div class="bottom-panel" id="bottomPanel">
    <div class="panel-title" id="panelTitle"></div>
    <div id="panelContentWrapper">
        <div id="panelContent"></div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

  <script>
    /***********************************************************
     * 1. SETUP AND INITIALIZATION
     ***********************************************************/
    const map = L.map("map", { zoomControl: false }).setView([51.127, 71.43], 12);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
    }).addTo(map);
    L.control.zoom({ position: 'topright' }).addTo(map);

    // Search bar UI logic (unchanged)
    const searchActivator = document.getElementById("searchActivator");
    const topSearchBar = document.getElementById("topSearchBar");
    let hideTimer = null;
    function showSearchBar(){ clearTimeout(hideTimer); topSearchBar.classList.add("show"); }
    function hideSearchBar(){ topSearchBar.classList.remove("show"); }
    function startHideTimer(){ hideTimer = setTimeout(hideSearchBar, 2000); }
    searchActivator.addEventListener("mouseenter", showSearchBar);
    searchActivator.addEventListener("mouseleave", startHideTimer);
    searchActivator.addEventListener("touchstart", showSearchBar, { passive: true });
    topSearchBar.addEventListener("mouseleave", startHideTimer);
    topSearchBar.addEventListener("touchstart", () => clearTimeout(hideTimer), { passive: true });

    /***********************************************************
     * 2. STATE MANAGEMENT
     ***********************************************************/
    let originalData = [];
    let activeMapLayers = []; // To keep track of layers on the map for easy removal
    let markersLoaded = false;

    // --- Filter State ---
    let displayMode = 'works'; // Default mode: 'works' or 'status'
    let selectedWorks = [];    // e.g., ['–î–∞', '–ù–µ—Ç']
    let selectedStatuses = []; // e.g., ['–ö–∞—Ä–∫–∞—Å', '–§—É–Ω–¥–∞–º–µ–Ω—Ç']

    // --- Filter Categories ---
    const WORKS_CATEGORIES = {
      "–î–∞": { color: "#28a745" }, // Bright Green
      "–ù–µ—Ç": { color: "#dc3545" }, // Bright Red
      "–ù–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω": { color: "#888888" } // Gray
    };

    const STATUS_CATEGORIES = {
        '–ö–∞—Ä–∫–∞—Å':      { shape: 'triangle', color: '#28a745' }, // Green
        '–°–µ—Ç—å':        { shape: 'triangle', color: '#fd7e14' }, // Orange
        '–§—É–Ω–¥–∞–º–µ–Ω—Ç':   { shape: 'triangle', color: '#800080' }, // Purple
        '–¢–µ—Ö. —É—Å–ª–æ–≤–∏–µ':{ shape: 'square',   color: '#ffc107' }, // Yellow-Orange (was orange)
        '–û—Ç–≤–æ–¥':       { shape: 'square',   color: '#ffeb3b' }, // Yellow
        '–°–æ–≥–ª–∞—Å–æ–≤–∞–Ω':  { shape: 'square',   color: '#007bff' }, // Blue
        '–ù–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω':{ shape: 'circle',   color: '#888888' }  // Gray
    };

    /***********************************************************
     * 3. DATA FETCHING AND PROCESSING
     ***********************************************************/
    fetch("https://script.google.com/macros/s/AKfycbxprxG-MDgk1ULTdQFAjpDr8_wPGkNnTmVjoawzUeGAFKRC-LgUPtRoTiBKVCWvQRAy/exec")
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        return response.json();
      })
      .then(data => {
        originalData = data;
        markersLoaded = true;
        console.log(`–ó–∞–≥—Ä—É–∂–µ–Ω–æ ${originalData.length} –æ—Å—Ç–∞–Ω–æ–≤–æ–∫.`);
        applyFiltersAndRedraw(); // Initial draw
      })
      .catch(e => {
        console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–ª–∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö:", e);
        alert("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∫–∞—Ä—Ç—ã. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ–Ω—Å–æ–ª—å (F12) –¥–ª—è –¥–µ—Ç–∞–ª–µ–π.");
      });

    /***********************************************************
     * 4. STATUS & SHAPE HELPER FUNCTIONS
     ***********************************************************/

    // Determines status based on "–†–∞–±–æ—Ç–∞–µ—Ç" column (Column 12)
    function getWorkStatus(item) {
        const workVal = (item.rabotaet || "").trim();
        if (workVal.toLowerCase() === '–¥–∞') return { status: '–î–∞', color: WORKS_CATEGORIES['–î–∞'].color };
        if (workVal.toLowerCase() === '–Ω–µ—Ç') return { status: '–ù–µ—Ç', color: WORKS_CATEGORIES['–ù–µ—Ç'].color };
        return { status: '–ù–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω', color: WORKS_CATEGORIES['–ù–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω'].color };
    }

    // Determines status with hierarchy for the "–°—Ç–∞—Ç—É—Å" view
    function getInstallStatus(item) {
        const install = (item.status_ustanovki || "").trim().toLowerCase();
        if (install === '–∫–∞—Ä–∫–∞—Å') return STATUS_CATEGORIES['–ö–∞—Ä–∫–∞—Å'];
        if (install === '—Å–µ—Ç—å') return STATUS_CATEGORIES['–°–µ—Ç—å'];
        if (install === '—Ñ—É–Ω–¥–∞–º–µ–Ω—Ç') return STATUS_CATEGORIES['–§—É–Ω–¥–∞–º–µ–Ω—Ç'];

        const tech = (item.teh_uslovie || "").trim().toLowerCase();
        if (tech === '–¥–∞') return STATUS_CATEGORIES['–¢–µ—Ö. —É—Å–ª–æ–≤–∏–µ'];

        const otvod = (item.otvod || "").trim().toLowerCase();
        if (otvod === '–¥–∞') return STATUS_CATEGORIES['–û—Ç–≤–æ–¥'];

        const approval = (item.soglasovanie || "").trim().toLowerCase();
        if (approval === '—Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω') return STATUS_CATEGORIES['–°–æ–≥–ª–∞—Å–æ–≤–∞–Ω'];

        return STATUS_CATEGORIES['–ù–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω'];
    }

    /***********************************************************
     * 5. MARKER AND CLUSTER CREATION
     ***********************************************************/
    
    // Creates a custom HTML icon
    function createIcon(shape, color, size = 20) {
        let style = `width:${size}px; height:${size}px; background-color:${color}; border:1px solid #000; box-shadow: 0 0 3px rgba(0,0,0,0.5);`;
        if (shape === 'circle') {
            style += 'border-radius:50%;';
        } else if (shape === 'triangle') {
            style += `background-color: transparent; border-left: ${size/2}px solid transparent; border-right: ${size/2}px solid transparent; border-bottom: ${size}px solid ${color}; width:0; height:0;`;
        } // 'square' is default (border-radius: 0)

        const iconHTML = `<div style="${style}"></div>`;
        return L.divIcon({
            html: iconHTML,
            className: 'my-div-icon', // important for removing default styles
            iconSize: [size, size],
            iconAnchor: [size / 2, size / 2]
        });
    }

    // Generic function to create a MarkerClusterGroup
    function createClusterGroup() {
        return L.markerClusterGroup({
            maxClusterRadius: 60,
            iconCreateFunction: cluster => {
                const count = cluster.getChildCount();
                let size = 30 + count / 10;
                size = Math.min(Math.max(size, 30), 50);

                // Use the color of the most numerous marker type in the cluster
                const markers = cluster.getAllChildMarkers();
                const colorCount = markers.reduce((acc, m) => {
                    const c = m.options.icon.options.html.match(/background-color:(.*?);|border-bottom:.*?solid(.*?);/);
                    const color = c[1] ? c[1].trim() : c[2].trim();
                    acc[color] = (acc[color] || 0) + 1;
                    return acc;
                }, {});

                const dominantColor = Object.keys(colorCount).reduce((a, b) => colorCount[a] > colorCount[b] ? a : b, '#888888');

                return L.divIcon({
                    html: `<div style="background-color:${dominantColor}; border: 2px solid #555; border-radius:50%; width:${size}px; height:${size}px; display:flex; align-items:center; justify-content:center; color:#000; font-weight:bold; font-size: ${Math.max(10, size/2.5)}px;">${count}</div>`,
                    className: 'cluster-icon-only',
                    iconSize: [size, size]
                });
            }
        });
    }

    /***********************************************************
     * 6. MAP DRAWING AND FILTERING
     ***********************************************************/

    function clearMapLayers() {
        activeMapLayers.forEach(layer => map.removeLayer(layer));
        activeMapLayers = [];
    }

    // Main function to re-render the entire map based on current state
    function applyFiltersAndRedraw() {
        if (!markersLoaded) return;
        clearMapLayers();

        const searchQuery = document.getElementById("searchInput").value.toLowerCase().trim();
        let dataToDisplay = originalData.filter(item => {
            // Step 1: Filter by display mode logic
            let passModeFilter = false;
            if (displayMode === 'works') {
                if (selectedWorks.length === 0) {
                    passModeFilter = true;
                } else {
                    const workInfo = getWorkStatus(item);
                    passModeFilter = selectedWorks.includes(workInfo.status);
                }
            } else { // 'status' mode
                if (selectedStatuses.length === 0) {
                    passModeFilter = true;
                } else {
                    const statusInfo = getInstallStatus(item);
                    // We need to find the key ('–ö–∞—Ä–∫–∞—Å', etc.) for the returned object
                    const statusType = Object.keys(STATUS_CATEGORIES).find(key => STATUS_CATEGORIES[key] === statusInfo);
                    passModeFilter = selectedStatuses.includes(statusType);
                }
            }
            if (!passModeFilter) return false;

            // Step 2: Filter by search query
            if (searchQuery) {
                const stopName = (item.stopName || "").toLowerCase();
                const tabloId = String(item.tablo || "").toLowerCase();
                return stopName.includes(searchQuery) || tabloId.includes(searchQuery);
            }
            
            return true;
        });

        if (displayMode === 'works') {
            drawWorksView(dataToDisplay);
        } else {
            drawStatusView(dataToDisplay);
        }
        updateButtonLabels(dataToDisplay.length, originalData.length);
    }

    // Renders the "–†–∞–±–æ—Ç–∞–µ—Ç" view (all markers in one cluster group)
    function drawWorksView(data) {
        const clusterGroup = createClusterGroup();
        data.forEach(item => {
            const lat = parseFloat(item.lat), lng = parseFloat(item.lng);
            if (isNaN(lat) || isNaN(lng)) return;

            const workInfo = getWorkStatus(item);
            const marker = L.marker([lat, lng], { icon: createIcon('circle', workInfo.color) });
            marker.bindPopup(`<b>ID –¢–∞–±–ª–æ:</b> ${item.tablo || "-"} ...`); // Add full popup content
            addPopupContent(marker, item);
            clusterGroup.addLayer(marker);
        });
        map.addLayer(clusterGroup);
        activeMapLayers.push(clusterGroup);
    }

    // Renders the "–°—Ç–∞—Ç—É—Å" view (separate clusters for each shape)
    function drawStatusView(data) {
        const clusters = {
            circle: createClusterGroup(),
            square: createClusterGroup(),
            triangle: createClusterGroup()
        };

        data.forEach(item => {
            const lat = parseFloat(item.lat), lng = parseFloat(item.lng);
            if (isNaN(lat) || isNaN(lng)) return;

            const statusInfo = getInstallStatus(item);
            const marker = L.marker([lat, lng], { icon: createIcon(statusInfo.shape, statusInfo.color) });
            addPopupContent(marker, item);

            if (clusters[statusInfo.shape]) {
                clusters[statusInfo.shape].addLayer(marker);
            }
        });

        Object.values(clusters).forEach(cluster => {
            map.addLayer(cluster);
            activeMapLayers.push(cluster);
        });
    }

    function addPopupContent(marker, item) {
        const popupContent = `
          <b>ID –¢–∞–±–ª–æ:</b> ${item.tablo || "-"} (${item.number || "-"})<br>
          <b>–£–ª–∏—Ü–∞:</b> ${item.street || "-"}<br>
          <b>–ù–∞–∑–≤–∞–Ω–∏–µ:</b> ${item.stopName || "-"}<br>
          <b>–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ:</b> ${item.direction || "-"}<br>
          <b>–†–∞–π–æ–Ω:</b> ${item.district || "-"}<br>
          <hr style="margin: 5px 0;">
          <b>–†–∞–±–æ—Ç–∞–µ—Ç:</b> ${item.rabotaet || "-"}<br>
          <b>–°—Ç–∞—Ç—É—Å —É—Å—Ç–∞–Ω–æ–≤–∫–∏:</b> ${item.status_ustanovki || "-"}<br>
          <b>–°–æ–≥–ª–∞—Å–æ–≤–∞–Ω–∏–µ:</b> ${item.soglasovanie || "-"}
        `;
        marker.bindPopup(popupContent);
    }


    /***********************************************************
     * 7. UI EVENT LISTENERS & PANEL LOGIC
     ***********************************************************/

    // --- Bottom Panel ---
    const overlay = document.getElementById("overlay");
    const bottomPanel = document.getElementById("bottomPanel");
    function togglePanel(title, contentHtml, isScrollable = false) {
      const panelTitleElem = document.getElementById("panelTitle");
      const panelContentElem = document.getElementById("panelContent");
      const panelContentWrapper = document.getElementById("panelContentWrapper");

      if(bottomPanel.classList.contains("active") && panelTitleElem.innerText === title){
        closePanel();
      } else {
        panelTitleElem.innerText = title;
        panelContentElem.innerHTML = contentHtml;
        panelContentWrapper.classList.toggle("panel-content-scrollable", isScrollable);
        bottomPanel.classList.add("active");
        overlay.style.display = "block";
      }
    }
    function closePanel() {
      bottomPanel.classList.remove("active");
      overlay.style.display = "none";
    }
    overlay.addEventListener("click", closePanel);
    
    // --- Update Button Labels ---
    function updateButtonLabels(filteredCount, totalCount) {
        document.getElementById("worksFilterLabel").innerText = `${selectedWorks.length > 0 ? selectedWorks.join('/') : '–í—Å–µ'} (${filteredCount}/${totalCount})`;
        document.getElementById("statusFilterLabel").innerText = `${selectedStatuses.length > 0 ? '–í—ã–±—Ä–∞–Ω–æ' : '–í—Å–µ'} (${filteredCount}/${totalCount})`;

        // Highlight active mode button
        document.querySelectorAll('.control-buttons .btn').forEach(b => b.classList.remove('active-filter'));
        if (displayMode === 'works') {
            document.getElementById('worksFilterToggle').classList.add('active-filter');
        } else {
            document.getElementById('statusFilterToggle').classList.add('active-filter');
        }
    }

    // --- Legend Button ---
    document.getElementById("legendToggle").addEventListener("click", () => {
        const worksLegend = Object.keys(WORKS_CATEGORIES).map(cat => `
            <div class="legend-row">
              <div class="legend-icon" style="background-color:${WORKS_CATEGORIES[cat].color};"></div> ${cat}
            </div>`).join('');

        const statusLegend = Object.keys(STATUS_CATEGORIES).map(cat => {
            const info = STATUS_CATEGORIES[cat];
            const iconStyle = info.shape === 'triangle'
                ? `background-color: transparent; border-left: 10px solid transparent; border-right: 10px solid transparent; border-bottom: 20px solid ${info.color}; width:0; height:0; border-radius:0;`
                : `background-color:${info.color}; border-radius: ${info.shape === 'circle' ? '50%' : '0'};`;
            return `
                <div class="legend-row">
                    <div class="legend-icon" style="${iconStyle}"></div> ${cat}
                </div>`;
        }).join('');

        const legendHtml = `
            <div class="legend-container">
                <div class="legend-section">
                    <div class="legend-title">–†–µ–∂–∏–º "–†–∞–±–æ—Ç–∞–µ—Ç"</div>
                    ${worksLegend}
                </div>
                <hr style="width:100%; border-top: 1px solid #eee; margin: 10px 0;">
                <div class="legend-section">
                    <div class="legend-title">–†–µ–∂–∏–º "–°—Ç–∞—Ç—É—Å"</div>
                    ${statusLegend}
                </div>
            </div>`;
        togglePanel("–õ–µ–≥–µ–Ω–¥–∞", legendHtml, true);
    });

    // --- Filter Button Handlers ---
    document.getElementById('worksFilterToggle').addEventListener('click', () => {
        displayMode = 'works';
        const currentSelection = selectedWorks;
        const categories = Object.keys(WORKS_CATEGORIES);
        let html = '<div class="filter-buttons">';
        categories.forEach(cat => {
            const active = currentSelection.includes(cat) ? "active" : "";
            html += `<button class="${active}" onclick="toggleFilterItem('works', '${cat}')">${cat}</button>`;
        });
        html += `<button class="clear-btn" onclick="clearFilterItems('works')">–û—á–∏—Å—Ç–∏—Ç—å</button></div>`;
        togglePanel("–§–∏–ª—å—Ç—Ä –ø–æ —Å—Ç–∞—Ç—É—Å—É —Ä–∞–±–æ—Ç—ã", html);
    });

    document.getElementById('statusFilterToggle').addEventListener('click', () => {
        displayMode = 'status';
        const currentSelection = selectedStatuses;
        const categories = Object.keys(STATUS_CATEGORIES);
        let html = '<div class="filter-buttons">';
        categories.forEach(cat => {
            const active = currentSelection.includes(cat) ? "active" : "";
            html += `<button class="${active}" onclick="toggleFilterItem('status', '${cat}')">${cat}</button>`;
        });
        html += `<button class="clear-btn" onclick="clearFilterItems('status')">–û—á–∏—Å—Ç–∏—Ç—å</button></div>`;
        togglePanel("–§–∏–ª—å—Ç—Ä –ø–æ —Å—Ç–∞—Ç—É—Å—É —É—Å—Ç–∞–Ω–æ–≤–∫–∏", html, true);
    });

    // --- Generic Filter Item Click/Clear Handlers ---
    window.toggleFilterItem = function(type, value) {
        const selectionArray = (type === 'works') ? selectedWorks : selectedStatuses;
        const index = selectionArray.indexOf(value);
        if (index > -1) {
            selectionArray.splice(index, 1);
        } else {
            selectionArray.push(value);
        }
        applyFiltersAndRedraw();
        // Refresh panel to show updated active buttons
        const buttonToClick = (type === 'works') ? 'worksFilterToggle' : 'statusFilterToggle';
        document.getElementById(buttonToClick).click(); // Close
        document.getElementById(buttonToClick).click(); // Re-open
    };

    window.clearFilterItems = function(type) {
        if (type === 'works') {
            selectedWorks = [];
        } else {
            selectedStatuses = [];
        }
        applyFiltersAndRedraw();
        closePanel();
    };

    // --- Search Handlers ---
    document.getElementById("searchBtn").addEventListener("click", applyFiltersAndRedraw);
    document.getElementById("searchInput").addEventListener("keypress", e => { if (e.key === "Enter") applyFiltersAndRedraw(); });

  </script>
</body>
